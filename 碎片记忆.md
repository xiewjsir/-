### 计算机原理与应用

#### 1、内存泄漏达到一定程度会引发OOM。

内存泄漏是指编写的代码中含有bug，不是指会引发程序执行结果错误那种，而是不可达的对象停留在堆中，即代码中含有对象的强引用没有没释放掉，导致该无用的对象无法被垃圾收集器收集。
假设内存足够大，而内存泄漏的情况并不严重，只要还有足够的空间分配给新的对象，那样即使内存泄漏也不会引发OOM。

### redis

#### 1、redis的pipeline

redis客户端执行一条命令分4个过程:

```
发送命令－〉命令排队－〉命令执行－〉返回结果
```

这个过程称为Round trip time(简称RTT, 往返时间)，mget mset有效节约了RTT，但大部分命令（如hgetall，并没有mhgetall）不支持批量操作，需要消耗N次RTT
，这个时候需要pipeline（管道）来解决这个问题

> 引用 [redis pipeline的使用](https://www.cnblogs.com/-wenli/p/12922089.html)

#### 2、redis的事务

### 数据结构

#### 1、树的基本概概念

- 先序遍历（根左右）
- 中序遍历（左根右）
- 后序遍历（左右根）
- 广度遍历 ：按照二叉树的层次进行遍历
- 其它：先序遍历和后序遍历不能唯一地确定一棵树
- 完全二叉树——若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。
- 满二叉树——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。
- 平衡二叉树——平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

### 数据库

#### 什么是MVCC？

MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。
> 引用 [正确的理解MySQL的MVCC及实现原理](https://www.cnblogs.com/xuwc/p/13873611.html)

### golang

#### Golang指针

- *类型:普通指针类型，用于传递对象地址，不能进行指针运算。
- unsafe.Pointer:通用指针类型，用于转换不同类型的指针，不能进行指针运算，不能读取内存存储的值（必须转换到某一类型的普通指针）。
- uintptr:用于指针运算，GC 不把 uintptr 当指针，uintptr 无法持有对象。uintptr 类型的目标会被回收。

unsafe.Pointer 是桥梁，可以让任意类型的指针实现相互转换，也可以将任意类型的指针转换为 uintptr 进行指针运算。 unsafe.Pointer
不能参与指针运算，比如你要在某个指针地址上加上一个偏移量，Pointer是不能做这个运算的，那么谁可以呢? 就是uintptr类型了，只要将Pointer类型转换成uintptr类型，做完加减法后，转换成Pointer，通过*
操作，取值，修改值，随意。
**总结：unsafe.Pointer 可以让你的变量在不同的普通指针类型转来转去，也就是表示为任意可寻址的指针类型。而 uintptr 常用于与 unsafe.Pointer 打配合，用于做指针运算。**

#### 调试

- gctrace用途主要是用于跟踪GC的不同阶段的耗时与GC前后的内存量对比

```
GODEBUG='gctrace=1' go run main.go
GODEBUG=schedtrace=1 go run main.go
```

#### 如何输出 Go 汇编

对于写好的 go 源码，生成对应的 Go 汇编，大概有下面几种

- 方法 1 先使用 go build -gcflags "-N -l" main.go 生成对应的可执行二进制文件</br>
再使用 go tool objdump -s "main\." main 反编译获取对应的汇编 反编译时"main\."表示只输出 main 包中相关的汇编"main\.main" 则表示只输出 main 包中 main 方法相关的汇编

- 方法 2 使用 go tool compile -S -N -l main.go 这种方式直接输出汇编,示例：go tool compile -S -N -l testmap.go | grep "CALL" ：
- 方法 3 使用go build -gcflags="-N -l -S" main.go 直接输出汇编</br>
 **注意：在使用这些命令时，加上对应的 flag，否则某些逻辑会被编译器优化掉，而看不到对应完整的汇编代码**
- Go 也提供一个工具可以帮助我们查看代码从源码到 AST 再到最终 汇编的过程:GOSSAFUNC=main go build main.go

> -l 禁止内联 -N 编译时，禁止优化 -S 输出汇编代码
> 引用 [Golang 汇编入门知识总结](https://cloud.tencent.com/developer/article/1692904)

#### GOLANG数据类型之数值类型
- golang中用 int、int8、int16、int32、int64表示有符号的数据类型，用uint、uint8、uint16、uint32、uint64表示无符号的数据类型
- int为整数默认推导的数据类型，其表示范围和操作系统位数有关，即32位系统可表示-2^31~2^31-1（等同于int32），64位系统为-2^63~2^63-1（等同于int64）, int8表示用1个字节（1byte，即8bit）来存储一个数值，其范围即为-2^7~2^7-1，其他的类似
- byte类型，等同于uint8，可存储0~255的数值，所有的ASCII码都可用其存储
- rune类型，等同于int32，可用来存储4字节的字符，如中文
- 查看变量类型的函数 fmt.Printf("%T", 变量名)，查看变量占用字节的函数 unsafe.Sizeof(变量名)
- 浮点类型分为float32和float64，值得注意的是这两种类型跟操作系统无关，默认的类型即为放float64，也是推荐使用类型，float32是单精度（占用4字节），float64为双精度（占用8字节），故后者表示的范围更广，精度更高。浮点数存储时由符号位+指数位+尾数位组成

#### 中缀表达式转后缀表达式
> 从左到右遍历中缀表达式的每个数字和符号,若是数字就输出,即成为后缀表达式的一部分;
若是符号,则判断其与栈顶符号的优先级,是右括号或优先级低于栈顶符号(乘除优先加减),则栈顶元素依次出栈并输出,并将当前符号进栈,一直到最终输出后缀表达式位置.

9+(3-1)*3+10 /2 ===>> 9 3 1 - 3 * + 10 2 / +